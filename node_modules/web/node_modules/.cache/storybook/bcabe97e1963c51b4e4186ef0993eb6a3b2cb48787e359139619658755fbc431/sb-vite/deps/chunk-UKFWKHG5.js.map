{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/next/src/client/components/redirect-boundary.tsx"],
  "sourcesContent": ["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;MAyEgBA,kBAAgB,WAAA;eAAhBA;;MApCHC,uBAAqB,WAAA;eAArBA;;;;;4DApCoB;;;;AAWjC,aAASC,eAAe,OAQvB;AARuB,UAAA,EACtBC,UACAC,OACAC,aAAY,IAHU;AAStB,YAAMC,UAASC,GAAAA,YAAAA,WAAS;AAExBC,OAAAA,GAAAA,OAAAA,WAAU,MAAA;AACRC,eAAAA,QAAMC,gBAAgB,MAAA;AACpB,cAAIL,iBAAiBM,eAAAA,aAAaC,MAAM;AACtCN,mBAAOM,KAAKT,UAAU,CAAC,CAAA;UACzB,OAAO;AACLG,mBAAOO,QAAQV,UAAU,CAAC,CAAA;UAC5B;AACAC,gBAAAA;QACF,CAAA;MACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;OAAO;AAE1C,aAAO;IACT;AAEO,QAAML,wBAAN,cAAoCQ,OAAAA,QAAMK,UAAS;MASxD,OAAOC,yBAAyBC,OAAY;AAC1C,aAAIC,GAAAA,eAAAA,iBAAgBD,KAAAA,GAAQ;AAC1B,gBAAME,OAAMC,GAAAA,UAAAA,yBAAwBH,KAAAA;AACpC,gBAAMX,gBAAee,GAAAA,UAAAA,0BAAyBJ,KAAAA;AAC9C,iBAAO;YAAEb,UAAUe;YAAKb;UAAa;QACvC;AAEA,cAAMW;MACR;;MAGAK,SAA0B;AACxB,cAAM,EAAElB,UAAUE,aAAY,IAAK,KAAKiB;AACxC,YAAInB,aAAa,QAAQE,iBAAiB,MAAM;AAC9C,kBACE,GAAA,YAAA,KAACH,gBAAAA;YACCC;YACAE;YACAD,OAAO,MAAM,KAAKmB,SAAS;cAAEpB,UAAU;YAAK,CAAA;;QAGlD;AAEA,eAAO,KAAKqB,MAAMC;MACpB;MA7BAC,YAAYF,OAA8B;AACxC,cAAMA,KAAAA;AACN,aAAKF,QAAQ;UAAEnB,UAAU;UAAME,cAAc;QAAK;MACpD;IA2BF;AAEO,aAASL,iBAAiB,OAA2C;AAA3C,UAAA,EAAEyB,SAAQ,IAAV;AAC/B,YAAMnB,UAASC,GAAAA,YAAAA,WAAS;AACxB,cACE,GAAA,YAAA,KAACN,uBAAAA;QAAsBK;;;IAE3B;;;;;;;;",
  "names": ["RedirectBoundary", "RedirectErrorBoundary", "HandleRedirect", "redirect", "reset", "redirectType", "router", "useRouter", "useEffect", "React", "startTransition", "RedirectType", "push", "replace", "Component", "getDerivedStateFromError", "error", "isRedirectError", "url", "getURLFromRedirectError", "getRedirectTypeFromError", "render", "state", "setState", "props", "children", "constructor"]
}
